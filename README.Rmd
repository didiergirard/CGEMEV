---
title: "Alternative to Maximum Likelihood for two-parameter Matern Fields"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Fitting a Matérn covariance to a (possibly noisy) incomplete lattice observation 

The   `CGEMEV` R package provides tools for simulating realisations of a stationary isotropic Gaussian process when the correlation belongs to the common Matérn family with known regularity index $\nu \geq 0$ and for estimating  the correlation  range (also called  ``decorrelation length'') from one realisation on a (possibly incomplete) lattice. 
The variance of the field is simply estimated by the empirical variance that will be denoted $b_{\rm EV}$.
Presently the missing regions can be chosen to be several disks.

Three main functions are used: `gaussian.matern()`, `simulate()`
and `fsai11Precond.GEevalOnThetaGrid()`,  and a fourth function `grid.domain()` is required to precompute preconditioning sparse matrices.

These fonctions can be applied to a quite large grid (for example 512x512) even on a laptop. Indeed very fast 
computation of the quadratic form which occurs in the estimating equation is possible by using a conjugate-gradient (CG) solver preconditioned by a classical factored sparse approximate inverse (FSAI) preconditioning, the matrix-vector product, required in each CG iteration,  being obtained via FFT from the standard embedding of  in a circulant  matrix.

## Contents

- [Setting the probabilistic model](#Setting-the-probabilistic-model)
- [Simulating one (or several) realisations](#Simulating-one-(or-several)-realisations)
- [Plots of the random fields](#plots-of-the-random-fields)
- [Setting the uncomplete lattice](#setting-th-uncomplete-lattice)
- [Plotting data](#Plotting-data)
- [Plotting the estimating function](#plotting-the-estimating-function)
- [Estimating theta and the micro-ergodic parameter](#estimating-theta-and-the-micro-ergodic-parameter)

## Setting the probabilistic model

In this first version of the  `CGEMEV` package, we restrict ourselves to a simple domain [0,1]X[0,1]. For the example here, the simulations and the choice of observed sites are done using a grid 48x48
```{r }
library(CGEMEV)
#
n1grid<-48
cat("gaussian matern creation\n")
gm <- gaussian.matern(grid.size=n1grid,smoothness=0.5,range=0.5,factor=2)
cat("-> done\n")
```
NB: in the previous setting, factor=2 specifies the required extension factor of the observation domain. Indeed for this example the choice factor=1 would have entailed the message "FFT of covariance has negative values" which means that the embedding method (which doubles each length of the considered rectangular domain) would have not worked

## Simulating one (or several) realisations

```{r }
cat("simulation and plot\n")
set.seed(321)  # so that it is reproducible #
simulate(gm)
```

## Plots of the random fields

We can plot (and save), for example, 9 realizations:


```{r}
fullLattice.nineZs<- array(NA,c(n1grid*n1grid,9))
set.panel(2,3)
plot(gm)
fullLattice.nineZs[,1]<-gm$look[1:gm$n1,1:gm$n1]
ut <- system.time(
for (indexReplcitate in 2:9){
  set.seed(321+indexReplcitate)
  simulate(gm)
  plot(gm)
  fullLattice.nineZs[,indexReplcitate]<-gm$look[1:gm$n1,1:gm$n1]
  # image(x1,x2,matrix(Ztrue, gm1over2range0p5$n1, gm1over2range0p5$n1),asp=1)}
})
```

The following timing is for a MacBookPro3,1 Intel Core 2 Duo 2.6GHh  :
```{r}
ut   # for the simulation of 8 realisations :
```


## Setting the uncomplete lattice

Let us now define the regions  (actually 2 disks) where the observations will be missing, and precompute the preconditioning matrix:
```{r}
# md=missing.domains
ex1.md <- list(
  list(center=c(0.67841,0.67841),radius=0.17841),
	list(center=c(0.278412, 0.228412),radius=0.071365)
)
# gd=grid.domain
print(system.time(ex1WithN1eq48And2missindDisks.gd <- grid.domain(ex1.md,n1grid)))
```

## Plotting data

TODO


## Plotting the estimating function

Consider the first one of the above realizations, and the naive variance estimator $b_{\rm EV}$:
```{r}
# only observed outside the disks:
#z <- gm$look[1:gm$n1,1:gm$n1][!ex1WithN1eq48And2missindDisks.gd$missing.sites]
indexReplcitate <- 1
z <- fullLattice.nineZs[,indexReplcitate][!ex1WithN1eq48And2missindDisks.gd$missing.sites]
#
(bEV  <- mean(z**2))
#
candidateThetas1DGrid <- 1/gm$range * 10**seq(-1.1,1.1,,15)

(out <- fsai11Precond.GEevalOnThetaGrid(z,candidateThetas1DGrid,nu=gm$smoothness,grid.domain=ex1WithN1eq48And2missindDisks.gd,tolPGC=1e-03) )
#
#
#
set.panel(2,3)
{plot(candidateThetas1DGrid, out$values, type="l", 
                 col=1, lty=2,log="x")
    abline(h= bEV)
}
ut <- system.time(
for (indexReplcitate in 2:9){
  z <- fullLattice.nineZs[,indexReplcitate][!ex1WithN1eq48And2missindDisks.gd$missing.sites]
  bEV  <- mean(z**2)
  out <- fsai11Precond.GEevalOnThetaGrid(z,candidateThetas1DGrid,
        nu=gm$smoothness,grid.domain=ex1WithN1eq48And2missindDisks.gd,tolPGC=1e-03)
  plot(candidateThetas1DGrid, out$values, type="l", 
                 col=1, lty=2,log="x")
    abline(h= bEV)
})
```

Timing  for a MacBookPro3,1 Intel Core 2 Duo 2.6GHh :
```{r}
ut   # for computing the estimating equation for 8 realisations :
```

## Estimating theta and the micro-ergodic parameter

TODO
#
